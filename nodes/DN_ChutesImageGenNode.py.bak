import os
import json
import torch
from aiohttp import web

from .utils.api_routes import register_operation_handler
from .. import constants

class DN_ChutesImageGenNode:
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "node_configs": ("STRING", {"default": "{}", "multiline": False}),
            },
            "hidden": {
                "unique_id": "UNIQUE_ID"
            }
        }

    RETURN_TYPES = ("IMAGE", "STRING")
    RETURN_NAMES = ("image", "text")
    FUNCTION = "generate_image"
    CATEGORY = "Dado's Nodes/Chutes"

    def generate_image(self, node_configs, unique_id):
        print(f"unique_id: {unique_id}")
        
        dummy_image = torch.ones((1, 1, 3), dtype=torch.float32) * 0.5
        
        return (dummy_image, node_configs)

def load_model_config():
    config_path = os.path.join(constants.BASE_DIR, "configs", "chutes", "image_gen", "models.json")
    with open(config_path, 'r') as f:
        return json.load(f)

def load_model_schema(model_key):
    models_data = load_model_config()
    model_info = models_data.get(model_key)
    if not model_info or 'schema_file' not in model_info:
        return None
    
    schema_path = os.path.join(constants.BASE_DIR, "configs", "chutes", "image_gen", "schemas", model_info['schema_file'])
    with open(schema_path, 'r') as f:
        return json.load(f)

def normalize_integer_property(prop_details):
    if prop_details.get("type") == "integer":
        normalized_details = prop_details.copy()
        if "minimum" in normalized_details:
            normalized_details["min"] = normalized_details.pop("minimum")
        if "maximum" in normalized_details:
            normalized_details["max"] = normalized_details.pop("maximum")
        if "default" not in normalized_details:
            normalized_details["default"] = 0
        normalized_details["step"] = 10
        normalized_details["precision"] = 0
        normalized_details["type"] = "number"
        return normalized_details
    return prop_details

def normalize_string_property(prop_details):
    if prop_details.get("type") == "string":
        normalized_details = prop_details.copy()
        normalized_details["default"] = ""
        normalized_details["options"] = {"multiline": True}
        if "title" in normalized_details:
            del normalized_details["title"]
        return normalized_details
    return prop_details

def normalize_number_property(prop_details, key_name):
    if prop_details.get("type") == "number":
        normalized_details = prop_details.copy()
        if "minimum" in normalized_details:
            normalized_details["min"] = normalized_details.pop("minimum")
        if "maximum" in normalized_details:
            normalized_details["max"] = normalized_details.pop("maximum")
        if "guidance_scale" in key_name or "cfg_scale" in key_name:
            normalized_details["step"] = 1
            normalized_details["precision"] = 1
        return normalized_details
    return prop_details

def normalize_seed_property(prop_details):
    if prop_details.get("anyOf"):
        integer_type_details = next((item for item in prop_details["anyOf"] if item.get("type") == "integer"), None)
        if integer_type_details:
            return normalize_integer_property(integer_type_details)
    return prop_details

def prepare_ordered_widgets_from_schema(schema_data):
    properties = schema_data.get('definitions', {}).get('GenerationInput', {}).get('properties', {})
    
    widget_order = ["prompt", "negative_prompt", "seed", "width", "height", "guidance_scale", "true_cfg_scale", "num_inference_steps"]
    
    ordered_widgets = []
    for key in widget_order:
        if key in properties:
            prop_details = properties[key]
            if key == "seed":
                prop_details = normalize_seed_property(prop_details)
            elif prop_details.get("type") == "integer":
                prop_details = normalize_integer_property(prop_details)
            elif prop_details.get("type") == "number":
                prop_details = normalize_number_property(prop_details, key)
            elif prop_details.get("type") == "string":
                prop_details = normalize_string_property(prop_details)
            ordered_widgets.append({key: prop_details})
    
    remaining_keys = [k for k in properties if k not in widget_order]
    remaining_keys.sort()
    
    for key in remaining_keys:
        prop_details = properties[key]
        if prop_details.get("type") == "integer":
            prop_details = normalize_integer_property(prop_details)
        elif prop_details.get("type") == "number":
            prop_details = normalize_number_property(prop_details, key)
        elif prop_details.get("type") == "string":
            prop_details = normalize_string_property(prop_details)
        ordered_widgets.append({key: prop_details})
        
    return {"widgets": ordered_widgets}

@register_operation_handler
async def handle_chutes_image_gen_request(request):
    data = await request.json()
    operation = data.get('operation')
    
    valid_operations = ['get_models', 'chutes_img_model']
    if operation not in valid_operations:
        return None
        
    if operation == 'get_models':
        models_data = load_model_config()
        model_display_names = [config.get("display_name", name) for name, config in models_data.items()]
        default_model_key = next((name for name, config in models_data.items() if config.get("default", False)), None)
        default_model_display_name = models_data[default_model_key].get("display_name", default_model_key) if default_model_key else (model_display_names[0] if model_display_names else None)
        
        return web.json_response({
            "models": model_display_names,
            "default": default_model_display_name,
            "model_mapping": {config.get("display_name", name): name for name, config in models_data.items()}
        })
    
    if operation == 'chutes_img_model':
        payload = data.get('payload')
        model_key = payload.get('model_key') if payload else None
        print(f"Extracted model_key: {model_key}")
        if not model_key:
            print("model_key is missing or None")
            return web.json_response({"error": "Missing model_key"}, status=400)
        
        schema_data = load_model_schema(model_key)
        print(f"schema: {json.dumps(schema_data, indent=2)}")
        if not schema_data:
            return web.json_response({"error": f"Schema not found for model: {model_key}"}, status=404)
        
        prepared_widgets = prepare_ordered_widgets_from_schema(schema_data)
        print(f"prepared_widgets: {json.dumps(prepared_widgets, indent=2)}")
        return web.json_response(prepared_widgets)
