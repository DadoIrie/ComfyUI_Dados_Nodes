import { app } from "../../scripts/app.js";
import { addValueControlWidget } from "../../scripts/widgets.js";

let EXTENSION_NAME, MESSAGE_ROUTE, chainCallback, fetchSend;
(async () => {
  const constants = await fetch('/dadosConstants').then(response => response.json());
  EXTENSION_NAME = constants.EXTENSION_NAME;
  MESSAGE_ROUTE = constants.MESSAGE_ROUTE;

  ({chainCallback, fetchSend} =
   await import(`/extensions/${EXTENSION_NAME}/common/js/utils.js`));
})().catch(error => console.error("Failed to load utilities:", error));

class WidgetValidator {
    static allowedTypes = ['combo', 'number', 'string'];
    
    static typeRequirements = {
        combo: {
            required: ['value', 'values', 'tooltip'],
            validators: {
                value: (value) => typeof value === 'string',
                values: (value) => Array.isArray(value),
                tooltip: (value) => typeof value === 'string'
            },
            expectedTypes: {
                value: 'string',
                values: 'array',
                tooltip: 'string'
            }
        },
        number: {
            required: ['value', 'options', 'tooltip'],
            validators: {
                value: (value) => typeof value === 'number',
                options: (value) => typeof value === 'object' && value !== null,
                tooltip: (value) => typeof value === 'string'
            },
            expectedTypes: {
                value: 'number',
                options: 'object',
                tooltip: 'string'
            },
            options: {
                required: ['min', 'max', 'step', 'precision'],
                validators: {
                    min: (value) => typeof value === 'number',
                    max: (value) => typeof value === 'number',
                    step: (value) => typeof value === 'number',
                    precision: (value) => typeof value === 'number' // must be 0 for integer types
                },
                expectedTypes: {
                    min: 'number',
                    max: 'number',
                    step: 'number',
                    precision: 'number'
                }
            }
        },
        string: {
            required: ['value', 'options'],
            validators: {
                value: (value) => typeof value === 'string',
                options: (value) => typeof value === 'object'
            },
            expectedTypes: {
                value: 'string',
                options: 'object'
            },
            options: {
                required: ['multiline'],
                validators: {
                    multiline: (value) => typeof value === 'boolean'
                },
                expectedTypes: {
                    multiline: 'boolean'
                }
            }
        }
    };
    
    static mainFieldValidators = {
        name: (value) => typeof value === 'string',
        type: (value) => typeof value === 'string' && this.allowedTypes.includes(value)
    };
    
    static validateMainFields(config) {
        for (const [field, validator] of Object.entries(this.mainFieldValidators)) {
            if (!(field in config)) {
                throw new Error(`Expected string for ${field}, got missing field`);
            }
            if (!validator(config[field])) {
                if (field === 'type') {
                    throw new Error(`Expected one of [${this.allowedTypes.join(', ')}] for type, got ${config[field]}`);
                }
                throw new Error(`Expected string for ${field}, got ${typeof config[field]}`);
            }
        }
        
        return true;
    }
    
    static validate(config) {
        this.validateMainFields(config);
        
        const errors = [];
        const requirements = this.typeRequirements[config.type];
        
        for (const field of requirements.required) {
            if (!(field in config)) {
                errors.push(`Missing required field: ${field}`);
            }
        }
        
        for (const field in config) {
            if (!requirements.required.includes(field) && !['name', 'type', 'callback'].includes(field)) {
                errors.push(`Unknown field: ${field}. Allowed fields are: ${requirements.required.join(', ')}, callback`);
            }
        }
        
        for (const [field, validator] of Object.entries(requirements.validators)) {
            if (field in config && !validator(config[field])) {
                errors.push(`Invalid type for ${field}: expected ${requirements.expectedTypes[field]}, got ${typeof config[field]}`);
            }
        }
        
        // Validate nested objects
        for (const field in requirements) {
            if (!['required', 'validators', 'expectedTypes'].includes(field) &&
                typeof requirements[field] === 'object' &&
                requirements[field] !== null) {
                
                if (!(field in config)) {
                    errors.push(`Missing required field: ${field}`);
                }
                else if (typeof config[field] !== 'object' || config[field] === null) {
                    errors.push(`Invalid type for ${field}: expected object, got ${typeof config[field]}`);
                }
            }
        }
        
        if (errors.length > 0) {
            throw new Error(errors.join('; '));
        }
        
        return true;
    }
}

class WidgetFactory {
    static createWidget(node, config) {
        WidgetValidator.validate(config);
        
        let widgetOptions = {};
        
        if (config.type === 'number') {
            widgetOptions = { ...config.options };
        } else if (config.type === 'combo') {
            widgetOptions = { values: config.values };
        }
        
        let widget;
        if (config.type === 'string' && config.options.multiline) {
            const stringWidget = app.widgets['STRING'](node, config.name, ["STRING", { multiline: true }]);
            widget = stringWidget.widget;
            widget.value = config.value;
            // START: Store new value for string widgets on key press
            const originalCallback = widget.callback;
            widget.callback = (value, graphcanvas, callbackNode, pos, event) => {
                node.chutesImageGenNodeHandler.updateNodeConfigs(config.name, value);
                if (originalCallback) {
                    originalCallback(value, graphcanvas, callbackNode, pos, event);
                }
            };
            // END: Store new value for string widgets on key press
        } else {
            widget = node.addWidget(config.type, config.name, config.value, config.callback || (() => {}), widgetOptions);
            widget.tooltip = config.tooltip;
        }

        if (config.name === "seed" && config.type === "number") {
            const seedControl = addValueControlWidget(node, widget, 'randomize');
            seedControl.name = "seed_control";
            seedControl.callback = (value) => {
                node.chutesImageGenNodeHandler.widgetCallback({ name: seedControl.name, value: value, type: "combo" });
                widget.callback(widget.value);
                return value;
            };
            widget.linkedWidgets = [seedControl];
            node.chutesImageGenNodeHandler.ensureWidgetState(seedControl);
        }
        node.chutesImageGenNodeHandler.ensureWidgetState(widget);

        return widget;
    }
}

class DN_ChutesImageGenNodeHandler {
    constructor(node) {
        this.node = node;
        this.configsWidget = this.node.widgets?.find(w => w.name === "node_configs");
        this.modelMapping = {};
        this.widgetTooltips = {
            "seed": "Seed for random number generation",
            "width": "Width of the generated image",
            "height": "Height of the generated image",
            "prompt": "Text prompt for image generation",
            "negative_prompt": "Negative prompt for image generation",
            "guidance_scale": "Classifier-Free Guidance scale",
            "num_inference_steps": "Number of denoising steps"
        };
    }

    getConfigs() {
        return this.configsWidget?.value ? JSON.parse(this.configsWidget.value) : {};
    }

    setConfigs(configs) {
        this.configsWidget.value = JSON.stringify(configs, null, 2);
    }

    updateNodeConfigs(widgetName, value) {
        if (this.configsWidget && widgetName !== "node_configs") {
            let configs = this.getConfigs();
            if (widgetName === "model" && this.modelMapping && this.modelMapping[value]) {
                configs[widgetName] = this.modelMapping[value];
            } else {
                configs[widgetName] = value;
            }
            this.setConfigs(configs);
        }
    }

    ensureWidgetState(widget) {
        if (!this.configsWidget || widget.name === "node_configs" || widget.type === "button") {
            return;
        }

        const configs = this.getConfigs();
        if (configs[widget.name] !== undefined) {
            if (widget.name === "model" && this.modelMapping) {
                const storedModelKey = configs[widget.name];
                const displayValue = Object.keys(this.modelMapping).find(key => this.modelMapping[key] === storedModelKey);
                if (displayValue) {
                    widget.value = displayValue;
                }
            } else {
                widget.value = configs[widget.name];
            }
        } else {
            this.updateNodeConfigs(widget.name, widget.value);
        }
    }

    widgetCallback(changedWidget) {
        if (changedWidget.name === "model") {
            this.rebuildInputWidgets(changedWidget.value);
        }
        this.updateNodeConfigs(changedWidget.name, changedWidget.value);
    }

    async rebuildInputWidgets(modelDisplayName) {
        const modelKey = this.modelMapping[modelDisplayName];
        if (!modelKey) return;

        const widgetsToRemove = this.node.widgets.filter(w => w.name !== "node_configs" && w.name !== "model");
        for (let i = widgetsToRemove.length - 1; i >= 0; i--) {
            const widget = widgetsToRemove[i];
            if (widget.linkedWidgets) {
                for (let j = widget.linkedWidgets.length - 1; j >= 0; j--) {
                    const lw = widget.linkedWidgets[j];
                    if (this.node.widgets.includes(lw)) {
                        this.node.removeWidget(lw);
                    }
                }
            }
            if (this.node.widgets.includes(widget)) {
                this.node.removeWidget(widget);
            }
        }

        const payload = { model_key: modelKey };
        console.log("Sending payload to backend:", payload);
        const response = await fetchSend(MESSAGE_ROUTE, this.node.id, "chutes_img_model", payload);
        console.log("Backend response:", response);

        if (response && response.widgets) {
            response.widgets.forEach(widgetData => {
                const widgetName = Object.keys(widgetData)[0];
                const widgetConfig = widgetData[widgetName];
                
                const finalWidgetConfig = {
                    name: widgetName,
                    type: widgetConfig.type,
                    value: widgetConfig.default || (widgetConfig.type === "number" ? 0 : ""),
                    callback: (value) => { this.widgetCallback({ name: widgetName, value, type: widgetConfig.type }); return value; }
                };

                if (finalWidgetConfig.type !== "string") {
                    finalWidgetConfig.tooltip = this.widgetTooltips[widgetName] || widgetName;
                }

                if (widgetConfig.type === "integer" || widgetConfig.type === "number") {
                    finalWidgetConfig.options = {
                        min: widgetConfig.min,
                        max: widgetConfig.max,
                        step: widgetConfig.step,
                        precision: widgetConfig.precision
                    };
                }

                if (finalWidgetConfig.type === "string") {
                    finalWidgetConfig.options = { multiline: widgetConfig.options.multiline };
                }

                WidgetFactory.createWidget(this.node, finalWidgetConfig);
            });
        }
        
        this.node.setDirtyCanvas(true);
    }
    
    async initialize() {
        if (this.configsWidget) {
            this.configsWidget.hidden = true;
            this.configsWidget.computeSize = () => [0, -4];
        }

        const response = await fetchSend(MESSAGE_ROUTE, this.node.id, "get_models");
        const modelOptions = response.models;
        const defaultModel = response.default;
        this.modelMapping = response.model_mapping;
        
        const modelWidgetConfig = {
            name: "model",
            type: "combo",
            value: defaultModel,
            values: modelOptions,
            tooltip: "Select the model to use for image generation",
            callback: (value) => { this.widgetCallback({ name: "model", value, type: "combo" }); return value; }
        };
        
        this.modelWidget = WidgetFactory.createWidget(this.node, modelWidgetConfig);

        await this.rebuildInputWidgets(this.modelWidget.value);
        
        this.node.setDirtyCanvas(true)
    }
}

app.registerExtension({
    name: "DN_ChutesImageGenNode",
    async beforeRegisterNodeDef(nodeType, nodeData, app) {
        if (nodeData.name === "DN_ChutesImageGenNode") {
            chainCallback(nodeType.prototype, 'onNodeCreated', async function() {
                this.chutesImageGenNodeHandler = new DN_ChutesImageGenNodeHandler(this);
                setTimeout(async () => {
                    await this.chutesImageGenNodeHandler.initialize();
                }, 0);
            });
        }
    }
});
